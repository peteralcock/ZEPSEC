class Vulnerability < ApplicationRecord
  include Vulnerability::Ransackers
  include CustomFieldable
  include Monitorable
  include Readable
  include StripTextFields
  include Papertrailable
  include MassSave

  has_paper_trail(
    skip: [:processed, :processed_by_id],
    unless: Proc.new { |record| record.skip_versioning }
  )

  EXPLOIT_MATURITIES = {
    not_defined: 'not_defined',
    high: 'high',
    functional: 'functional',
    poc: 'poc',
    unproven: 'unproven'
  }.freeze

  ACTUALITIES = {
    not_set: 'not_set',
    actual: 'actual',
    not_actual: 'not_actual'
  }.freeze

  RELEVANCES = {
    not_set: 'not_set',
    relevant: 'relevant',
    not_relevant: 'not_relevant'
  }.freeze

  STATES = {
    modified: 'modified',
    published: 'published',
    not_published: 'not_published'
  }.freeze

  FEEDS = {
    custom: 'custom',
    nvd: 'nvd',
    bdu: 'bdu'
  }.freeze

  # source (feed) of vulnerability info
  enum feed: FEEDS
  enum custom_actuality: ACTUALITIES, _prefix: true
  enum custom_relevance: RELEVANCES, _prefix: true
  enum actuality: ACTUALITIES, _prefix: true
  enum relevance: RELEVANCES, _prefix: true
  enum state: STATES, _prefix: true
  enum exploit_maturity: EXPLOIT_MATURITIES, _prefix: true
  enum custom_exploit_maturity: EXPLOIT_MATURITIES, _prefix: true

  scope :actual_and_relevant, -> {
    where(
      custom_actuality: 'actual',
      custom_relevance: 'relevant'
    )
  }

  attr_accessor(
    :custom_vendors_str,
    :custom_products_str,
    :custom_codenames_str
  )

  before_validation :set_processed_by_id
  before_validation :set_actuality
  before_validation :set_relevance
  before_validation :set_state
  before_validation :set_custom_vendors
  before_validation :set_custom_products
  before_validation :set_custom_codenames
  # TODO: add set_cwes like custom_codenames
  before_save :set_published
  before_save :set_modified
  before_save :set_changed_fields

  validates :codename, uniqueness: true
  validates :codename, length: { in: 3..250 }
  validates :published, presence: true, if: ->(obj){ obj.custom_published.blank? }
  validates :custom_published, presence: true, if: ->(obj){ obj.published.blank? }
  validates :vulnerability_kind_id, numericality: { only_integer: true, allow_blank: true }
  validates :cvss3, inclusion: { in: 0.0..10.0, allow_blank: true }
  validates :cvss2, inclusion: { in: 0.0..10.0, allow_blank: true }
  validates :feed, inclusion: { in: Vulnerability.feeds.values}
  validates :actuality, inclusion: { in: Vulnerability.actualities.values}
  validates :custom_actuality,
    inclusion: { in: Vulnerability.custom_actualities.values}
  validates :relevance, inclusion: { in: Vulnerability.relevances.values}
  validates :custom_relevance,
    inclusion: { in: Vulnerability.custom_relevances.values}
  validates :state,
    inclusion: { in: Vulnerability.states.values}
  validates :exploit_maturity,
    inclusion: { in: Vulnerability.exploit_maturities.values}
  validates :custom_exploit_maturity,
    inclusion: { in: Vulnerability.custom_exploit_maturities.values}
  validates :vendors, array_elements_length: {min: 1, max: 250}
  validates :products, array_elements_length: {min: 1, max: 250}
  validates :custom_vendors, array_elements_length: {min: 1, max: 250}
  validates :custom_products, array_elements_length: {min: 1, max: 250}

  belongs_to :processor, foreign_key: :processed_by_id, class_name: 'User', optional: true

  belongs_to :vulnerability_kind, optional: true

  has_many :vulnerability_bulletin_members, dependent: :delete_all
  has_many :vulnerability_bulletins, through: :vulnerability_bulletin_members

  def field_changed?(field)
    return false if changed_fields.blank?
    changed_fields.include?(field.to_s)
  end

  # TODO: use or delete
  def exploit_maturity?
    maturity = custom_exploit_maturity || exploit_maturity
    return false if maturity == 'not_defined'
    return false if maturity == 'unproven'
    true
  end

  def custom_exploit_maturity?
    maturity = custom_exploit_maturity
    return false if maturity == 'not_defined'
    return false if maturity == 'unproven'
    true
  end

  def show_full_name
    codename
  end

  def report
    report = Reports.report_by_name(:vulnerability_bulletin_report)
    file = report.new(User.find(1), :docx, {vulnerability_bulletin_id: id})
      .rendered_file
    {file: file, name: "#{report.human_name}.docx"}
  end

  private

  def set_custom_vendors
    return if custom_vendors_str.blank?
    self.custom_vendors = str_to_arr(custom_vendors_str)
  end

  def set_custom_products
    return if custom_products_str.blank?
    self.custom_products = str_to_arr(custom_products_str)
  end

  def set_custom_codenames
    return if custom_codenames_str.blank?
    self.custom_codenames = str_to_arr(custom_codenames_str)
  end

  def str_to_arr(string)
    string.split(',')
          .map(&:strip)
  end

  def set_actuality
    self.actuality = Custom::VulnerabilityCustomization.cast_actuality(self)
    if custom_actuality_not_set? || custom_actuality.nil?
      self.custom_actuality = actuality
    end
  end

  def set_relevance
    if custom_relevance_not_set? || custom_relevance.nil?
      self.custom_relevance = relevance
    end
  end

  def set_state
    if blocked
      self.state = if published == modified
                     :published
                   else
                     :modified
                   end
    else
      self.state = :not_published unless state.present?
    end
  end

  def set_processed_by_id
    return unless processed_changed?
    self.processed_by_id = current_user.id
    if processed
      self.processed_at = DateTime.now
    else
      self.processed_at = nil
    end
  end

  def set_published
    return if published.present?
    self.published = custom_published
    self.published_time = true if custom_published_time?

  end

  def set_modified
    return if modified.present?
    self.modified = published
    self.modified_time = true if published_time?
  end

  def set_changed_fields
    return if changes.blank?
    self.changed_fields = changes.each_with_object([]) do |(name, changes), memo|
      memo << name unless changes.first.nil? && changes.last.blank?
      if name == 'raw_data'
        if references_from_raw(changes.first) != references_from_raw(changes.last)
          memo << 'references'
        end
        if versions_from_raw(changes.first) != versions_from_raw(changes.last)
          memo << 'versions'
        end
        if cpes_from_raw(changes.first) != cpes_from_raw(changes.last)
          memo << 'cpe'
        end
      end
    end
  end

  def references_from_raw(raw)
    return '' if raw == '{}'
    raw.dig('cve', 'references', 'reference_data') || []
  end

  def versions_from_raw(raw)
    return '' if raw == '{}'
    NvdBase::Parser.vendors_products(raw)
  end

  def cpes_from_raw(raw)
    return '' if raw == '{}'
    raw.dig('configurations', 'nodes') || []
  end
end
